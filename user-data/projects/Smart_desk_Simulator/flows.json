[
    {
        "id": "00faea911c2e17d1",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "d7a9ea05a589f28e",
        "type": "mqtt-broker",
        "name": "",
        "broker": "localhost",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "5ed1155aaed18428",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "Local Influx 2",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://localhost:8086",
        "timeout": 10,
        "rejectUnauthorized": true
    },
    {
        "id": "44cfd562e37fa1a8",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-contrib-influxdb": "0.7.0"
        }
    },
    {
        "id": "34345f3168db1b64",
        "type": "mqtt out",
        "z": "00faea911c2e17d1",
        "name": "Smart_Desk_Publisher",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "d7a9ea05a589f28e",
        "x": 1000,
        "y": 120,
        "wires": []
    },
    {
        "id": "661921696d231a7c",
        "type": "inject",
        "z": "00faea911c2e17d1",
        "name": "Tick-Smart Desk",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 210,
        "y": 240,
        "wires": [
            [
                "92d994a8c47c6d3e"
            ]
        ]
    },
    {
        "id": "92d994a8c47c6d3e",
        "type": "function",
        "z": "00faea911c2e17d1",
        "name": "Smart Desk Sensor Simulation",
        "func": "// ===== SMART DESK IoT SIMULATOR - FINAL VERSION =====\nfunction rand(min, max) { return Math.round(Math.random() * (max - min) + min); }\nfunction rfloat(min, max, d = 1) { return parseFloat((Math.random() * (max - min) + min).toFixed(d)); }\n\nconst REAL_TICK_SEC = 30;\nconst DEMO_MIN_PER_TICK = 3;\nconst TICK_SIM_SEC = DEMO_MIN_PER_TICK * 60;\n\n// Desk height constants (PRIMARY IoT SENSOR)\nconst SITTING_HEIGHT_MIN = 72;\nconst SITTING_HEIGHT_MAX = 82;\nconst STANDING_HEIGHT_MIN = 105;\nconst STANDING_HEIGHT_MAX = 115;\nconst STANDING_THRESHOLD = 90;\nconst MIN_STAND_DURATION_SEC = 15 * 60;  // 15 minutes required for reset\n\n// Get simulation state\nlet state = flow.get(\"focusState\") || {\n    mode: \"focus\",\n    remainingSec: 25 * 60,\n    sitStreakSec: 0,\n    standCyclesToday: 0,\n    lastResetDate: null,\n    wasStanding: true,\n    standStartTime: null,\n    lastStandingHeight: null,\n    alertTriggered: false\n};\n\n// Get warning timers (IoT sensor based)\nlet highCo2Sec = flow.get(\"highCo2Sec\") || 0;\nlet lowLightSec = flow.get(\"lowLightSec\") || 0;\n\n// Reset stand cycles every day\nconst today = new Date().toDateString();\nif (!state.lastResetDate || state.lastResetDate !== today) {\n    state.standCyclesToday = 0;\n    state.lastResetDate = today;\n    node.warn(`üåÖ New day started! Stand cycles reset.`);\n}\n\n// Advance Pomodoro timer\nstate.remainingSec -= TICK_SIM_SEC;\nif (state.remainingSec <= 0) {\n    if (state.mode === \"focus\") {\n        state.mode = \"break\";\n        state.remainingSec = 5 * 60;\n    } else {\n        state.mode = \"focus\";\n        state.remainingSec = 25 * 60;\n    }\n}\n\n// --- DESK HEIGHT LOGIC (PRIMARY IoT SENSOR) ---\nlet deskHeightCm;\nconst sitMinutes = state.sitStreakSec / 60;\n\nif (sitMinutes < 45) {\n    // Phase 1: Normal sitting (before alert threshold)\n    deskHeightCm = rand(SITTING_HEIGHT_MIN, SITTING_HEIGHT_MAX);\n    state.lastStandingHeight = null;\n    state.alertTriggered = false;\n\n} else if (sitMinutes >= 45 && sitMinutes < 48) {\n    // Phase 2: Alert triggered, user hasn't responded yet\n    deskHeightCm = rand(SITTING_HEIGHT_MIN, SITTING_HEIGHT_MAX);\n    state.lastStandingHeight = null;\n\n    if (!state.alertTriggered) {\n        node.warn(`üö® ERGONOMIC ALERT! User has been sitting for ${Math.round(sitMinutes)} minutes!`);\n        state.alertTriggered = true;\n    }\n\n} else {\n    // Phase 3: User responds by raising desk\n    if (state.lastStandingHeight === null) {\n        state.lastStandingHeight = rand(STANDING_HEIGHT_MIN, STANDING_HEIGHT_MAX);\n        node.warn(`üìà User responding to alert - RAISING DESK to ${state.lastStandingHeight} cm`);\n    }\n    deskHeightCm = state.lastStandingHeight;\n}\n\n// Derive sitting/standing state from physical sensor\nlet sitStandState = deskHeightCm > STANDING_THRESHOLD ? 1 : 0;\n\n// --- PRESENCE DETECTION (IoT SENSOR: PIR or Pressure Mat) ---\nlet present;\n// CRITICAL FIX: If there's an active sitting streak, user MUST be present\nif (state.sitStreakSec > 0) {\n    present = true;  // Prevents \"desk is idle\" during active session\n} else {\n    // Only use probabilistic detection when truly idle\n    present = Math.random() < (state.mode === \"focus\" ? 0.8 : 0.3);\n}\n\n// --- AUTO-RESET STREAK AFTER 15 MINUTES OF STANDING ---\nif (state.standStartTime !== null && sitStandState === 1) {\n    const standDurationSec = Date.now() / 1000 - state.standStartTime;\n\n    if (standDurationSec >= MIN_STAND_DURATION_SEC && state.sitStreakSec > 0) {\n        node.warn(`‚úÖ Stand duration reached ${(standDurationSec / 60).toFixed(1)} min - Sit streak RESET!`);\n        state.sitStreakSec = 0;\n        state.alertTriggered = false;\n    }\n}\n\n// --- SITTING STREAK MANAGEMENT ---\nif (present && sitStandState === 0) {\n    // User is sitting\n\n    if (state.wasStanding && state.standStartTime !== null) {\n        // Just sat down after standing period\n        const standDurationSec = Date.now() / 1000 - state.standStartTime;\n\n        if (standDurationSec >= MIN_STAND_DURATION_SEC) {\n            // Stood long enough - RESET streak\n            state.sitStreakSec = TICK_SIM_SEC;\n            state.alertTriggered = false;\n            node.warn(`ü™ë Sitting... Streak RESET ‚úÖ (stood for ${(standDurationSec / 60).toFixed(1)} min) (Desk: ${deskHeightCm} cm)`);\n        } else {\n            // Didn't stand long enough - streak CONTINUES\n            state.sitStreakSec += TICK_SIM_SEC;\n            node.warn(`ü™ë Sitting again... Streak CONTINUES ‚ö†Ô∏è at ${Math.round(state.sitStreakSec / 60)} min (only stood ${(standDurationSec / 60).toFixed(1)} min) (Desk: ${deskHeightCm} cm)`);\n        }\n        state.standStartTime = null;\n        state.lastStandingHeight = null;\n\n    } else {\n        // Continue sitting\n        state.sitStreakSec += TICK_SIM_SEC;\n        const sitMin = Math.round(state.sitStreakSec / 60);\n\n        // Log only at key milestones for cleaner console\n        if (sitMin % 5 === 0 || sitMin === 42 || sitMin === 45 || sitMin === 48) {\n            if (sitMin === 42) {\n                node.warn(`‚ö†Ô∏è Approaching alert threshold ‚Äî ${sitMin} min sitting (Desk: ${deskHeightCm} cm)`);\n            } else {\n                node.warn(`ü™ë Sitting... Streak: ${sitMin} min (Desk: ${deskHeightCm} cm)`);\n            }\n        }\n    }\n    state.wasStanding = false;\n\n} else if (state.sitStreakSec > 0 && !state.wasStanding && sitStandState === 1) {\n    // User just stood up (state transition)\n    state.standStartTime = Date.now() / 1000;\n    state.standCyclesToday += 1;\n    state.wasStanding = true;\n    state.lastStandingHeight = deskHeightCm;\n    node.warn(`‚¨ÜÔ∏è User stood up! Stand cycles: ${state.standCyclesToday} (Desk: ${deskHeightCm} cm) - Timer started!`);\n\n} else if (state.sitStreakSec > 0 && sitStandState === 1) {\n    // User is still standing\n    state.wasStanding = true;\n\n    // Optional: Log standing progress every 3 minutes\n    const standDurationSec = Date.now() / 1000 - state.standStartTime;\n    const standMin = Math.round(standDurationSec / 60);\n    if (standMin > 0 && standMin % 3 === 0) {\n        node.warn(`üßç Standing... ${standMin} min of ${MIN_STAND_DURATION_SEC / 60} min required (Desk: ${deskHeightCm} cm)`);\n    }\n}\n\n// --- GENERATE IoT SENSOR DATA ---\nconst temperatureC = rfloat(22, 26, 1);      // DHT22 sensor\nconst lightLux = rand(150, 600);             // Photoresistor/BH1750\nconst humidityPct = rand(35, 60);            // DHT22 sensor\nconst co2ppm = rand(500, 1400);              // MQ-135/SGP30 sensor\nconst noiseDb = rand(42, 74);                // Sound sensor\nconst screenOn = present ? 1 : 0;            // Screen detection (optional)\n\n// --- ENVIRONMENTAL SENSOR PROCESSING ---\n// Track high CO2 duration\nif (co2ppm > 1000) {\n    highCo2Sec += TICK_SIM_SEC;\n} else {\n    highCo2Sec = 0;\n}\n\n// Track low light duration\nif (present && lightLux < 250) {\n    lowLightSec += TICK_SIM_SEC;\n} else {\n    lowLightSec = 0;\n}\n\n// --- WARNING THRESHOLDS ---\nconst LONG_SIT_THRESHOLD_MIN = 45;\nconst HIGH_CO2_THRESHOLD_SEC = 15 * 60;      // 15 minutes\nconst LOW_LIGHT_THRESHOLD_SEC = 5 * 60;      // 5 minutes\n\nconst isSitting = deskHeightCm < STANDING_THRESHOLD;\nconst sitDuration = Math.round(state.sitStreakSec / 60);\n\nconst longSitWarning = (sitDuration >= LONG_SIT_THRESHOLD_MIN && isSitting) ? 1 : 0;\nconst dimLightWarning = (lowLightSec >= LOW_LIGHT_THRESHOLD_SEC) ? 1 : 0;\nconst highCo2Warning = (highCo2Sec >= HIGH_CO2_THRESHOLD_SEC) ? 1 : 0;\n\n// --- DESK HEIGHT RECOMMENDATIONS ---\nconst RECOMMENDED_STANDING_HEIGHT = 110;\nlet deskHeightRecommendation = \"\";\nlet deskPositionStatus = \"\";\n\nif (isSitting && sitDuration >= LONG_SIT_THRESHOLD_MIN) {\n    deskHeightRecommendation = `‚¨ÜÔ∏è RAISE DESK to ${RECOMMENDED_STANDING_HEIGHT} cm and stand!`;\n    deskPositionStatus = \"üî¥ Alert: Too long sitting\";\n} else if (isSitting && sitDuration >= 30) {\n    deskHeightRecommendation = `‚ö†Ô∏è Consider standing soon (desk at ${deskHeightCm} cm)`;\n    deskPositionStatus = \"üü° Warning: Approaching limit\";\n} else if (!isSitting) {\n    deskHeightRecommendation = `üëè Great! Standing at ${deskHeightCm} cm`;\n    deskPositionStatus = \"‚úÖ Standing - Healthy\";\n} else {\n    deskHeightRecommendation = `‚úÖ Sitting comfortably at ${deskHeightCm} cm`;\n    deskPositionStatus = \"‚úÖ Sitting - Normal\";\n}\n\n// --- BUILD ALERT MESSAGES (IMPROVED - only if all warnings are false the environment is balanced.else any warning the office environment is not suitable.) ---\nlet messages = [];\n\n// Calculate standing duration if actively standing\nlet standDurationMin = 0;\nif (state.standStartTime !== null && sitStandState === 1) {\n    standDurationMin = Math.round((Date.now() / 1000 - state.standStartTime) / 60);\n}\n\n// 1. ERGONOMIC ALERT - Only if CURRENTLY sitting\nif (longSitWarning && isSitting) {\n    messages.push(`üö® Sitting for ${sitDuration} min! ${deskHeightRecommendation}`);\n}\n\n// 2. STANDING PROGRESS\nif (state.sitStreakSec > 0 && !isSitting && state.standStartTime !== null) {\n    const remainingMin = Math.max(0, 15 - standDurationMin);\n    if (remainingMin > 0) {\n        messages.push(`üßç Standing: ${standDurationMin}/${15} min ‚Äî Keep going! ${remainingMin} min to reset streak.`);\n    } else {\n        messages.push(`‚úÖ Standing: ${standDurationMin} min ‚Äî Excellent! Streak resets when you sit again.`);\n    }\n}\n\n// 3. CRITICAL ENVIRONMENTAL ALERTS (15+ min)\nif (dimLightWarning) {\n    messages.push(\"üí° Lighting low for 5+ min ‚Äî increase ambient light to reduce eye strain.\");\n}\nif (highCo2Warning) {\n    messages.push(\"ü´Å CO‚ÇÇ high for 15+ min ‚Äî get fresh air or increase ventilation.\");\n}\n\n// 4. ELEVATED ENVIRONMENTAL CONDITIONS (early warning)\nif (co2ppm > 1000 && !highCo2Warning) {\n    const co2Min = Math.round(highCo2Sec / 60);\n    messages.push(`‚ö†Ô∏è CO‚ÇÇ elevated (${co2ppm} ppm, ${co2Min} min) ‚Äî monitor air quality.`);\n}\nif (lightLux < 250 && !dimLightWarning) {\n    const lightMin = Math.round(lowLightSec / 60);\n    messages.push(`‚ö†Ô∏è Light low (${lightLux} lux, ${lightMin} min) ‚Äî increase brightness.`);\n}\n\n// 5. CHECK IF ENVIRONMENT IS TRULY BALANCED\nconst envBalanced = (co2ppm <= 1000 && lightLux >= 250);\n\n// 6. DEFAULT STATUS (only if no alerts)\nif (!messages.length) {\n    if (present) {\n        if (isSitting) {\n            if (envBalanced) {\n                messages.push(`All good ‚Äî sitting at ${deskHeightCm} cm. Environment balanced.`);\n            } else {\n                messages.push(`Sitting at ${deskHeightCm} cm. Monitor environment conditions.`);\n            }\n        } else {\n            if (envBalanced) {\n                messages.push(`Excellent! Standing at ${deskHeightCm} cm. Environment optimal.`);\n            } else {\n                messages.push(`Standing at ${deskHeightCm} cm. Monitor environment conditions.`);\n            }\n        }\n    } else {\n        messages.push(\"Desk is idle ‚Äî no user detected.\");\n    }\n}\n\n// --- SAVE STATE ---\nflow.set(\"focusState\", state);\nflow.set(\"highCo2Sec\", highCo2Sec);\nflow.set(\"lowLightSec\", lowLightSec);\n\n// --- BUILD UNIFIED IoT PAYLOAD ---\nconst timestamp = new Date().toISOString();\n\nconst unifiedPayload = {\n    // === METADATA ===\n    deskId: \"desk01\",\n    userId: \"user01\",\n    timestamp: timestamp,\n    mode: state.mode,\n\n    // === PRIMARY IoT DATA: ERGONOMICS ===\n    seating: {\n        present: present ? 1 : 0,\n        sitStandState: sitStandState,\n        sitStreakMin: sitDuration,\n        standCyclesToday: state.standCyclesToday,\n        deskHeightCm: deskHeightCm,\n        isSitting: isSitting ? 1 : 0,\n        deskPositionStatus: deskPositionStatus,\n        deskHeightRecommendation: deskHeightRecommendation\n    },\n\n    // === SECONDARY IoT DATA: ENVIRONMENT ===\n    environment: {\n        temperatureC: temperatureC,\n        humidityPct: humidityPct,\n        co2ppm: co2ppm,\n        noiseDb: noiseDb,\n        lightLux: lightLux,\n        highCo2Sec: highCo2Sec,\n        lowLightSec: lowLightSec\n    },\n\n    // === ALERTS & RECOMMENDATIONS ===\n    alerts: {\n        longSitWarning: longSitWarning,\n        dimLightWarning: dimLightWarning,\n        highCo2Warning: highCo2Warning,\n        smartDeskAssistant: messages.join(\" | \")\n    }\n};\n\n// Publish to MQTT\nmsg.topic = \"desk/desk01/telemetry\";\nmsg.payload = JSON.stringify(unifiedPayload);\n\n// Log payload size\nconst sizeBytes = Buffer.byteLength(msg.payload, 'utf8');\nnode.warn(`üì¶ IoT Payload Size: ${sizeBytes} bytes (${(sizeBytes / 1024).toFixed(2)} KB)`);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 120,
        "wires": [
            [
                "5f5dc9dd242b1b17",
                "3d1e7d7bc10a0588"
            ]
        ]
    },
    {
        "id": "afd6ced74296e452",
        "type": "mqtt in",
        "z": "00faea911c2e17d1",
        "name": "Smart Desk Telemetry IN",
        "topic": "desk/desk01/telemetry",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "d7a9ea05a589f28e",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 210,
        "y": 400,
        "wires": [
            [
                "a17d74df0fecba88"
            ]
        ]
    },
    {
        "id": "a17d74df0fecba88",
        "type": "json",
        "z": "00faea911c2e17d1",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 410,
        "y": 400,
        "wires": [
            [
                "8c58fa0660fa325d",
                "afdbd8acdcf68747",
                "2298db7fbec8d873"
            ]
        ]
    },
    {
        "id": "5a872dc6776bb546",
        "type": "influxdb out",
        "z": "00faea911c2e17d1",
        "influxdb": "5ed1155aaed18428",
        "name": "Seating Sensor Details",
        "measurement": "desk_seating",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "iot-org",
        "bucket": "smartDeskDatabase",
        "x": 1020,
        "y": 300,
        "wires": []
    },
    {
        "id": "8c58fa0660fa325d",
        "type": "function",
        "z": "00faea911c2e17d1",
        "name": "Capture Seating Sensor details",
        "func": "// Extract Seating Data from Unified Payload\nlet p = msg.payload;\nif (typeof p === \"string\") {\n    try { p = JSON.parse(p); }\n    catch (e) { node.warn(\"Parse error: \" + e.message); return null; }\n}\n\nif (!p || !p.deskId) return null;\n\nmsg.measurement = \"desk_seating\";\nmsg.tags = {\n    deskId: p.deskId,\n    userId: p.userId,\n    mode: p.mode\n};\n\nmsg.payload = {\n    // Existing fields - PRESERVED\n    present: p.seating.present,\n    sitStandState: p.seating.sitStandState,\n    sitStreakMin: p.seating.sitStreakMin,\n    standCyclesToday: p.seating.standCyclesToday,\n    deskHeightCm: p.seating.deskHeightCm,\n\n    // New fields - ADDITIONS\n    isSitting: p.seating.isSitting,\n    deskPositionStatus: p.seating.deskPositionStatus,\n    deskHeightRecommendation: p.seating.deskHeightRecommendation\n};\n\nmsg.timestamp = new Date(p.timestamp);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "\n",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 260,
        "wires": [
            [
                "5a872dc6776bb546"
            ]
        ]
    },
    {
        "id": "afdbd8acdcf68747",
        "type": "function",
        "z": "00faea911c2e17d1",
        "name": "Capture Environment Sensor Details",
        "func": "// Extract Environment Data from Unified Payload\nlet p = msg.payload;\nif (typeof p === \"string\") {\n    try { p = JSON.parse(p); }\n    catch (e) { node.warn(\"Parse error: \" + e.message); return null; }\n}\n\nif (!p || !p.deskId) return null;\n\nmsg.measurement = \"desk_environment\";\nmsg.tags = {\n    deskId: p.deskId,\n    userId: p.userId,\n    mode: p.mode\n};\n\n// Build environment message\nlet envMessages = [];\nif (p.alerts.dimLightWarning) envMessages.push(\"Lighting is low ‚Äî turn on lamp or open blinds.\");\nif (p.alerts.highCo2Warning) envMessages.push(\"CO‚ÇÇ is high ‚Äî open a window or take a fresh air break.\");\nif (!envMessages.length && p.seating.present) {\n    envMessages.push(`All good ‚Äî environment looks fine in ${p.mode} mode.`);\n}\n\nmsg.payload = {\n    // Existing fields - PRESERVED\n    temperatureC: p.environment.temperatureC,\n    humidityPct: p.environment.humidityPct,\n    co2ppm: p.environment.co2ppm,\n    noiseDb: p.environment.noiseDb,\n    lightLux: p.environment.lightLux,\n    highCo2Sec: p.environment.highCo2Sec,\n    lowLightSec: p.environment.lowLightSec,\n    dimLightWarning: p.alerts.dimLightWarning,\n    highCo2Warning: p.alerts.highCo2Warning,\n    environmentNotifyText: envMessages.join(\" | \")  // Compatibility field\n};\n\nmsg.timestamp = new Date(p.timestamp);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 420,
        "wires": [
            [
                "9b8a56e37aaff542"
            ]
        ]
    },
    {
        "id": "2298db7fbec8d873",
        "type": "function",
        "z": "00faea911c2e17d1",
        "name": "Build Desk Status Sensor",
        "func": "// Extract Status & Alerts Data from Unified Payload\nlet p = msg.payload;\nif (typeof p === \"string\") {\n    try { p = JSON.parse(p); }\n    catch (e) { node.warn(\"Parse error: \" + e.message); return null; }\n}\n\nif (!p || !p.deskId) return null;\n\nmsg.measurement = \"desk_status\";\nmsg.tags = {\n    deskId: p.deskId,\n    userId: p.userId,\n    mode: p.mode\n};\n\nmsg.payload = {\n    // Productivity metrics\n    present: p.seating.present,\n    \n    // Derived timers\n    highCo2Sec: p.environment.highCo2Sec,\n    lowLightSec: p.environment.lowLightSec,\n\n    // All warnings\n    longSitWarning: p.alerts.longSitWarning,\n    dimLightWarning: p.alerts.dimLightWarning,\n    highCo2Warning: p.alerts.highCo2Warning,\n\n    // Desk intelligence\n    isSitting: p.seating.isSitting,\n    deskHeightCm: p.seating.deskHeightCm,\n    sitStreakMin: p.seating.sitStreakMin,\n    deskPositionStatus: p.seating.deskPositionStatus,\n    deskHeightRecommendation: p.seating.deskHeightRecommendation,\n\n    // Master narrative\n    smartDeskAssistant: p.alerts.smartDeskAssistant\n};\n\nmsg.timestamp = new Date(p.timestamp);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 560,
        "wires": [
            [
                "da46810f98515547"
            ]
        ]
    },
    {
        "id": "9b8a56e37aaff542",
        "type": "influxdb out",
        "z": "00faea911c2e17d1",
        "influxdb": "5ed1155aaed18428",
        "name": "Environment & Light Sensor Details",
        "measurement": "desk_environment",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "iot-org",
        "bucket": "smartDeskDatabase",
        "x": 1080,
        "y": 420,
        "wires": []
    },
    {
        "id": "da46810f98515547",
        "type": "influxdb out",
        "z": "00faea911c2e17d1",
        "influxdb": "5ed1155aaed18428",
        "name": "Desk Status Sensor Details",
        "measurement": "desk_status",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "iot-org",
        "bucket": "smartDeskDatabase",
        "x": 1020,
        "y": 560,
        "wires": []
    },
    {
        "id": "5f5dc9dd242b1b17",
        "type": "function",
        "z": "00faea911c2e17d1",
        "name": "Capture payload size",
        "func": "let payloadString = typeof msg.payload === 'string'\n    ? msg.payload\n    : JSON.stringify(msg.payload);\n\nlet p = msg.payload;\nif (typeof p === \"string\") {\n    p = JSON.parse(p);\n}\n\n// Calculate size in bytes\nlet sizeInBytes = Buffer.byteLength(payloadString, 'utf8');\nlet sizeInKB = (sizeInBytes / 1024).toFixed(2);\n\n// Log it\nnode.warn(`üì¶ Payload Size: ${sizeInBytes} bytes (${sizeInKB} KB) unified payload ${JSON.stringify(p, null, 2)}`);\n\n// Store in message for later use\nmsg.payloadSize = sizeInBytes;\nmsg.payloadSizeKB = sizeInKB;\n\n// Add to context for tracking\nlet totalSize = context.get('totalSize') || 0;\nlet messageCount = context.get('messageCount') || 0;\n\ntotalSize += sizeInBytes;\nmessageCount += 1;\n\ncontext.set('totalSize', totalSize);\ncontext.set('messageCount', messageCount);\n\nlet avgSize = (totalSize / messageCount).toFixed(2);\nnode.warn(`üìä Average: ${avgSize} bytes | Total: ${messageCount} messages`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 20,
        "wires": [
            [
                "34345f3168db1b64"
            ]
        ]
    },
    {
        "id": "3d1e7d7bc10a0588",
        "type": "debug",
        "z": "00faea911c2e17d1",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 140,
        "wires": []
    }
]